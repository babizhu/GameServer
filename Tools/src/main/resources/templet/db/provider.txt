package PACKAGE_NAME.dao.impl;

import java.util.List;
import java.util.ArrayList;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import cn.javaplus.common.db.DAO2;
import cn.javaplus.common.db.DAO;
import PACKAGE_NAME.domain.CLASS_NAME;
import dbutils.IdUtil;
import java.util.concurrent.atomic.AtomicLong;
import cn.javaplus.common.util.Closer;

import java.sql.Connection;
import com.lemon.commons.database.ConnectionFetcher;

/**
 * 该文件自动生成, 禁止手动修改!
 */
public class CLASS_NAMEDAOImpl implements DAOTAIL<KEYS CLASS_NAME> {

	private static AtomicLong idMax = null;

	private ConnectionFetcher	fetcher;

	public CLASS_NAMEDAOImpl(ConnectionFetcher fetcher) {

		this.fetcher = fetcher;

		if(idMax == null) {

			String sql = "select max(KEY_COLUMN_NAME) as ids from TABLE_NAME";

			//初始化表中第一个元素的起始ID, 主要为了多个服务器合服的时候考虑主键冲突问题
			idMax = IdUtil.getInstance().initIdStart(fetcher, sql);
		}
	}

	@Override
	public void add(CLASS_NAME CLASS_PARAMETER) {

		PreparedStatement ps = null;

		ResultSet rs = null;

		Connection connection = null;

		try {

			String sql = "insert into TABLE_NAME (COLUMN_NAMES) "

					+ "values (COLUMN_?S)";

			connection = fetcher.getConnection();

			ps = connection.prepareStatement(sql);

			PS_SETS_ADD

			ps.executeUpdate();

		} catch (SQLException e) {

			throw new SQLRuntimeException(e);

		} finally {

			Closer.close(rs, ps);

			Closer.close(connection);
		}
	}

	@Override
	public void addAll(List<CLASS_NAME> CLASS_PARAMETERs) {

		PreparedStatement ps = null;

		ResultSet rs = null;

		Connection connection = null;

		try {
			String sql = "insert into TABLE_NAME (COLUMN_NAMES) "

					+ "values (COLUMN_?S)";

			connection = fetcher.getConnection();

			ps = connection.prepareStatement(sql);

			for (CLASS_NAME CLASS_PARAMETER : CLASS_PARAMETERs) {

				PS_SETS_ADD

				ps.addBatch();

			}

			ps.executeBatch();

		} catch (SQLException e) {

			throw new SQLRuntimeException(e);

		} finally {

			Closer.close(rs, ps);

			Closer.close(connection);
		}
	}

	@Override
	public void delete(PK_PARAMETER) {

		ResultSet rs = null;

		PreparedStatement ps = null;

		Connection connection = null;

		try {

			String sql = "delete from TABLE_NAME where PKCOLUMNS_S";

			connection = fetcher.getConnection();

			ps = connection.prepareStatement(sql);

			PK_PS_SETS

			ps.executeUpdate();

 		} catch (SQLException e) {

			throw new SQLRuntimeException(e);

		} finally {

			Closer.close(rs, ps);

			Closer.close(connection);
		}
	}

	@Override
	public void update(CLASS_NAME CLASS_PARAMETER) {

		PreparedStatement ps = null;

		ResultSet rs = null;

		Connection connection = null;

		try {

			String sql = "update TABLE_NAME set COLUMN_PARAMETERS where PKCOLUMNS_S";

			connection = fetcher.getConnection();

			ps = connection.prepareStatement(sql);

			PS_SETS_UPDATE

			ps.executeUpdate();

		} catch (SQLException e) {

			throw new SQLRuntimeException(e);

		} finally {

			Closer.close(rs, ps);

			Closer.close(connection);
		}
	}

	@Override
	public CLASS_NAME get(PK_PARAMETER) {

		PreparedStatement ps = null;

		ResultSet rs = null;

		Connection connection = null;

		CLASS_NAME CLASS_PARAMETER = null;

		try {

			String sql = "select * from TABLE_NAME where PK_COLUMNS";

			connection = fetcher.getConnection();

			ps = connection.prepareStatement(sql);

			PK_PS_SETS

			rs = ps.executeQuery();

			while (rs.next()) {

			CLASS_PARAMETER = mapping(rs);

			}

		} catch (SQLException e) {

			throw new SQLRuntimeException(e);

		} finally {

			Closer.close(rs, ps);

			Closer.close(connection);
		}

		return CLASS_PARAMETER;
	}

	@Override
	public List<CLASS_NAME> getAll() {

		PreparedStatement ps = null;

		ResultSet rs = null;

		Connection connection = null;

		List<CLASS_NAME> CLASS_PARAMETERs = new ArrayList<CLASS_NAME>();

		try {

			String sql = "select * from TABLE_NAME";

			connection = fetcher.getConnection();

			ps = connection.prepareStatement(sql);

			rs = ps.executeQuery();

			while (rs.next()) {

				CLASS_NAME CLASS_PARAMETER = new CLASS_NAME();

				CLASS_PARAMETER = mapping(rs);

				CLASS_PARAMETERs.add(CLASS_PARAMETER);
			}

		} catch (SQLException e) {

			throw new SQLRuntimeException(e);

		} finally {

			Closer.close(rs, ps);

			Closer.close(connection);
		}

		return CLASS_PARAMETERs;
	}

	@Override
	public int getCount() {

		PreparedStatement ps = null;

 		ResultSet rs = null;

		Connection connection = null;

		int count = 0;

 		try {

			String sql = "select count(*) from TABLE_NAME";

			connection = fetcher.getConnection();

			ps = connection.prepareStatement(sql);

			rs = ps.executeQuery();

			while (rs.next()) {

				count =  rs.getInt(1);
			}

		} catch (SQLException e) {

			throw new SQLRuntimeException(e);

		} finally {

 			Closer.close(rs, ps);

			Closer.close(connection);
		}

 		return count;
 	}

	private CLASS_NAME mapping(ResultSet rs) throws SQLException {

		CLASS_NAME CLASS_PARAMETER = new CLASS_NAME();

		RS_GETS

		return CLASS_PARAMETER;
	}

	@Override
	public int nextId() {

		return (int) idMax.addAndGet(1);
	}

	@Override
	public List<CLASS_NAME> findBy(String field, String o){

		PreparedStatement ps = null;

		ResultSet rs = null;

		Connection connection = null;

		List<CLASS_NAME> ls = new ArrayList<CLASS_NAME>();

		try {

			String sql = "select * from TABLE_NAME where " + field + " = ?";

			connection = fetcher.getConnection();

			ps = connection.prepareStatement(sql);

			ps.setString(1, o);

			rs = ps.executeQuery();

			while (rs.next()) {

				ls.add(mapping(rs));
			}

		} catch (SQLException e) {

			throw new SQLRuntimeException(e);

		} finally {

			Closer.close(rs, ps);

			Closer.close(connection);
		}

		return ls;
	}

	@Override
	public CLASS_NAME createDTO() {

		return new CLASS_NAME();
	}


	@Override
	public void clear() {

		PreparedStatement ps = null;

		Connection connection = null;

 		try {

			String sql = "delete from TABLE_NAME";

			connection = fetcher.getConnection();

			ps = connection.prepareStatement(sql);

			ps.executeUpdate();

		} catch (SQLException e) {

			throw new SQLRuntimeException(e);

		} finally {

			Closer.close(ps);

			Closer.close(connection);
		}
	}
}
